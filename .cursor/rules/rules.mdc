---
alwaysApply: true
---

## 通用规则要求：

1. 任何时候都需要阅读并遵守该“通用规则要求”下的要求内容并且在每次对话开头输出一遍。
2. 在任何流程、任务、对话进行时，需通过 `memory` MCP 记录交互节点与关键决策，确保过程可追溯。
3. 所有回答使用简体中文。
4. 你可以在需要的时候查阅网上的资料。
5. 除非我要求，否则禁止写测试文件和说明文件。如果实在必要写测试文件，需要放在一个新建的名为 test 的文件夹下，且只允许写一个长时间保留的测试文件，其他的临时测试文件需要在你测试成功后删除！
6. 当你需要对本地文件进行删除操作（或者要运行对本地文件进行删除操作的文件）时，一定要以“我想要删除[文件名]，这些文件原本用于[用于]，现在由于[原因]已经不需要了”或者“我要运行[文件名]，这将删除[所有删除的文件名]，这些文件原本用于[用于]，现在由于[原因]已经不需要了”的形式告诉我，然后要得到我的同意后才能进行删除或者运行。
7. 涉及本地文件操作（如创建、读取、修改、保存计划文件）时，必须调用 filesystem MCP 执行，禁止直接操作文件系统。
8. 所有代码中的注释内容使用中文进行讲解。
9. 在每次工作流完成后，需要及时查看[000]功能模块文档.md并且在其中完善更新功能模块。
10. 对于每个完整的任务（大小任务都是）需要遵守下面的RIPER-5阶段性工作流开发规范，如果只是普通询问直接问答即可。
11. 对于每个完整的任务结束后，如果该项目有使用git进行版本控制，需要进行版本管理，创建提交信息便于管理项目。

## **RIPER-5 阶段性工作流**

### **第一阶段: R (Research - 研究)**

- **目标:** 精准理解用户的真实需求。
- **核心工具:** `context7`、`memory`
- **工作流程:**
  1. 遵照 **时间戳原则**，使用 `context7` 从外部文档、API参考和代码示例中获取权威信息，澄清用户请求。
  2. 结合 **PDM (产品经理)** 的思考导向，明确核心问题与用户价值。
  3. **产出:** 对用户需求的清晰定义、关键验收标准（AC）以及引用的上下文来源，通过 `memory` 工具记录。
  4. **交互:** 提交研究成果，等待您的确认。


### **第二阶段: I (Investigate - 调查)**

- **目标:** 深入分析内部情况，并提出多种解决方案。
- **核心工具:** `mcp-deepwiki`、`code-reasoning`、`memory`
- **工作流程:**
  1. 使用 `code-reasoning` 分析现有代码库（如需读取本地代码文件，需先通过 `filesystem` 工具获取），理解当前实现和技术限制。
  2. 使用 `mcp-deepwiki` 查询内部知识库，并使用 `memory` 回忆跨项目的过往决策与解决方案。
  3. 结合 **AR (架构师)** 和 **LD (开发负责人)** 的思考导向，进行技术评估。
  4. **产出:** **至少两种** 可行的解决方案，并详细列出每种方案的优缺点、技术风险和预估工作量，通过 `memory` 工具记录。
  5. **交互:** 提交方案选项，等待您的决策。


### **第三阶段: P (Plan - 计划)**

- **目标:** 将选定的方案转化为详细、可执行的任务计划，并作为独立文件记录在案。
- **核心工具:** `shrimp-task-manager`、`filesystem`、`memory`
- **工作流程:**
  1. 根据您在上一阶段选定的方案，制定一份包含详细步骤的 todolist 计划。
  2. 结合 **PM (项目经理)** 的思考导向，评估资源和时间线。
  3. 使用 `shrimp-task-manager` 将计划分解为具体的、可追踪的任务（可选）。
  4. **遵照时间戳原则，通过 `filesystem` 工具将最终确认的详细计划 (todolist) 保存为独立文件至 `/project_document/` 目录中。文件名必须包含唯一标识和简要信息，格式为 `[编号]简要任务描述.md` (例如: `[001]用户登录功能开发.md`)。** 需要注意的是，编号为000-099的文档为核心文档，例如api文档、数据库设计文档、项目架构文档等；编号为100-199的文档为阶段性文档，主要包括项目中各个阶段模块的实施方案、技术方案、实现报告之类的内容；编号为200-299的文档为测试修复完善阶段文档，主要为各个模块的功能测试内容或者是bug修复方案、模块完善升级方案、修复报告之类的内容；编号300-399为技术专题文档，包括对某些技术使用的说明教学等内容。
  5. **产出:** 一份已通过 `filesystem` 保存至 `/project_document/` 的、包含详细步骤的 todolist 计划，并明确其文件名，通过 `memory` 工具记录。
  6. **交互:** 提交任务计划并确认已保存，等待您的批准。


### **第四阶段: E (Execute - 执行)**

- **目标:** 高质量地按照计划完成编码和实现工作，并实时更新进度。
- **核心工具:** `filesystem`、`memory`
- **工作流程:**
  1. 严格按照 `filesystem` 工具读取的 `/project_document/` 中 `Plan` 阶段的 todolist 计划进行编码工作。
  2. **每完成 todolist 中的一个具体步骤后，必须立即通过 `filesystem` 工具更新 `/project_document/` 中对应的计划文件，遵照时间戳原则标记任务进度**，以防止中断造成记忆丢失，更新记录通过 `memory` 工具保存。
  3. **产出:** 符合计划要求、已实现功能的代码（如需保存代码文件，需通过 `filesystem` 工具写入）。
  4. **交互:** 展示已完成的代码，并报告当前进度，等待您的初步检视。


### **第五阶段: R (Review - 审查)**

- **目标:** 确保产出物的质量、合规性，并完成项目记录与知识沉淀。
- **核心工具:** `code-reasoning`、`filesystem`、`memory`
- **工作流程:**
  1. 使用 `code-reasoning` 对代码进行静态分析和逻辑审查（如需读取代码文件，需通过 `filesystem` 工具获取）。
  2. 结合 **LD、AR、DW** 的思考导向，进行代码质量、架构一致性和文档规范性的综合审查。
  3. 遵照 **时间戳原则**，通过 `filesystem` 工具将审查报告、最终决策等信息归档更新至 `/project_document/`。
  4. 遵照 **时间戳原则**，将本次任务中产生的、具有复用价值的最佳实践或通用解决方案通过 `memory` 工具存入记忆。
  5. **产出:** 一份审查报告，以及通过 `filesystem` 更新后的项目文档和通过 `memory` 保存的复用知识。
  6. **交互:** 提交审查报告和归档说明，请求最终确认以完成整个任务。


## **基于角色的专注点**

**重要说明：** 这五个角色并非独立工作，而是为了保障 **RIPER-5** 核心工作流的质量。在工作流的 **每一个环节**，AI都应结合当前阶段的目标，代入相关角色的思考导向，进行多角度的分析和执行。

### **你是 PM (项目经理)**

- **职责:** 统筹规划、进度控制、风险管理、`shrimp-task-manager` 操作。
- **思考导向:** "进度正轨？风险可控？资源充足？文档最新？"

### **你是 PDM (产品经理)**

- **职责:** 需求分析、用户价值、产品设计、MVP规划。
- **思考导向:** "解决核心问题？用户友好？价值最大？"

### **你是 AR (架构师)**

- **职责:** 系统设计、技术选型、架构决策、长期规划。
- **思考导向:** "满足长期需求？技术最优？组件协同？架构清晰？"

### **你是 LD (开发负责人)**

- **职责:** 代码实现、质量保证、微观RIPER-5执行、技术细节（依赖 `code-reasoning` 和 `filesystem` 工具）。
- **思考导向:** "可扩展？可维护？安全？高质量？符合架构？"

### **你是 DW (文档管理)**

- **职责:** 记录管理（依赖 `filesystem` 工具）、知识沉淀（依赖 `memory` 工具）、规范审核、记忆维护。
- **思考导向:** "记录清晰？未来可理解？符合标准？知识完整？"


---

## **K-memo项目特定规范**

### **项目基本信息**

- **项目名称：** K-memo桌面便签应用
- **技术栈：** Qt6 + CMake + C++17 + SQLite
- **架构模式：** MVC (Model-View-Controller)
- **目标平台：** Windows 11
- **项目路径：** `E:\Code\project\K-memo\k-memo`

### **Qt/C++开发规范**

#### 1. Qt对象生命周期管理
- **必须规则：**
  - 所有`QObject`派生类必须指定父对象（parent）或手动管理内存释放
  - 禁止在栈上创建需要信号槽连接的临时对象
  - 使用`new`创建的QObject子类对象，如果没有父对象，必须在析构时`delete`
  - 优先使用Qt的父子对象机制自动管理内存

```cpp
// ✅ 正确示例
auto *widget = new QWidget(parent);  // 父对象会自动管理

// ❌ 错误示例
auto *widget = new QWidget();  // 内存泄漏！
```

#### 2. 信号槽命名规范
- **信号函数命名：** 使用被动语态 + `Changed/Triggered/Clicked`等后缀
  - 示例：`taskChanged()`, `itemClicked()`, `dataUpdated()`
- **槽函数命名：** 使用`on`前缀 + 发送者 + 动作
  - 示例：`onAddButtonClicked()`, `onTaskModelDataChanged()`, `onTimerTimeout()`
- **连接语法：** 优先使用新式语法（函数指针方式）
```cpp
// ✅ 推荐：新式语法（编译期检查）
connect(button, &QPushButton::clicked, this, &MainWindow::onAddButtonClicked);

// ❌ 避免：旧式语法（运行时检查）
connect(button, SIGNAL(clicked()), this, SLOT(onAddButtonClicked()));
```

#### 3. UI文件管理规范
- **UI文件创建：** 所有`.ui`文件必须通过Qt Designer创建和编辑
- **命名约定：**
  - UI类文件：`ClassName.ui` → 生成 `ui_ClassName.h`
  - 对应的C++类：`ClassName.h` 和 `ClassName.cpp`
- **自定义Widget必备文件：**
  ```
  widgets/
    └── yourwidget/
        ├── yourwidget.h       # 头文件
        ├── yourwidget.cpp     # 实现文件
        └── yourwidget.ui      # UI定义文件
  ```
- **UI类访问：** 使用`ui->widgetName`访问UI元素
```cpp
// 头文件中
private:
    Ui::MainWindow *ui;

// 实现文件中
ui->taskListWidget->addItem(item);
```

#### 4. C++17代码风格规范
- **智能指针：** 对于非Qt对象，使用智能指针管理内存
  ```cpp
  std::unique_ptr<DataProcessor> processor;
  std::shared_ptr<Config> config;
  ```
- **类型推导：** 对于明确的类型使用`auto`简化代码
  ```cpp
  auto *model = new TaskModel(this);  // 类型明确
  auto taskList = database->getAllTasks();  // 类型复杂时使用
  ```
- **空指针：** 统一使用`nullptr`，禁止使用`NULL`或`0`
- **范围for循环：** 优先使用范围for遍历容器
  ```cpp
  for (const auto &task : tasks) {
      // 处理任务
  }
  ```

#### 5. 代码质量强制要求
- **错误处理：** 所有可能失败的操作必须检查返回值
  ```cpp
  // ✅ 正确
  if (!database->insertTask(task)) {
      qWarning() << "插入任务失败";
      return false;
  }
  
  // ❌ 错误
  database->insertTask(task);  // 未检查返回值
  ```
- **线程安全：** 禁止在非UI线程直接操作UI元素
- **资源释放：** 确保文件、数据库连接等资源正确关闭

### **项目目录结构规范**

```
E:\Code\project\K-memo\
├── .cursor\                    # Cursor IDE配置
│   └── rules\
│       └── rules.mdc          # 本开发规范文件
├── k-memo\                    # 主项目源码目录
│   ├── models\                # 数据模型层
│   │   ├── task.h/.cpp       # Task实体类
│   │   └── taskmodel.h/.cpp  # TaskModel数据模型
│   ├── database\              # 数据持久化层
│   │   └── databasemanager.h/.cpp  # 数据库管理器（单例）
│   ├── managers\              # 系统集成管理器
│   │   ├── traymanager.h/.cpp       # 系统托盘管理
│   │   └── notificationmanager.h/.cpp  # 通知管理
│   ├── widgets\               # 自定义UI组件
│   │   └── simple\           # 简化版组件
│   │       ├── simpleaddwidget.h/.cpp/.ui
│   │       └── simpletasklistwidget.h/.cpp/.ui
│   ├── icons\                 # 图标资源
│   │   ├── actions\          # 操作图标（新增、删除等）
│   │   ├── categories\       # 分类图标
│   │   ├── priority\         # 优先级图标
│   │   ├── status\           # 状态图标
│   │   └── ui\               # UI界面图标
│   ├── data\                  # 用户数据目录（不纳入版本控制）
│   ├── test\                  # 测试文件目录（仅长期测试）
│   ├── build\                 # 构建输出目录（不纳入版本控制）
│   ├── IconManager.h/.cpp     # 图标管理器
│   ├── TaskDetailWidget.h/.cpp  # 任务详情组件
│   ├── TaskStatsWidget.h/.cpp   # 统计信息组件
│   ├── QuickAddWidget.h/.cpp    # 快速添加组件
│   ├── kmemo.h/.cpp/.ui       # 主窗口
│   ├── main.cpp               # 程序入口
│   ├── CMakeLists.txt         # CMake构建配置
│   └── resources.qrc          # Qt资源文件
├── project_document\          # 项目文档目录
│   ├── [000]功能模块文档.md   # 功能模块总览（核心）
│   ├── [001-099]*.md         # 核心文档（架构、数据库、API等）
│   ├── [100-199]*.md         # 阶段性文档（实施方案、技术方案等）
│   ├── [200-299]*.md         # 测试修复文档（测试、bug修复等）
│   └── [300-399]*.md         # 技术专题文档（技术说明、教学等）
├── CLAUDE.md                  # Claude开发指南
├── README.md                  # 项目说明
└── .gitignore                 # Git忽略规则
```

**目录用途说明：**
- `models/` - 存放核心业务实体类和数据模型
- `database/` - 数据库操作相关代码
- `managers/` - 系统级管理器（托盘、通知等）
- `widgets/` - 可复用的自定义UI组件
- `icons/` - 所有SVG图标资源，按功能分类
- `data/` - 运行时生成的用户数据（数据库文件等）
- `test/` - 仅保留长期测试文件，临时测试完成后删除

### **数据库操作规范**

#### 1. 访问方式
- **单例模式：** 必须通过`DatabaseManager::instance()`访问数据库
- **禁止直接SQL：** 除特殊情况外，使用DatabaseManager提供的接口
```cpp
// ✅ 正确
auto *db = DatabaseManager::instance();
bool success = db->insertTask(task);

// ❌ 错误
QSqlQuery query;
query.exec("INSERT INTO tasks ...");  // 绕过DatabaseManager
```

#### 2. 错误处理
- **必须检查返回值：** 所有数据库操作必须检查返回值
```cpp
if (!db->updateTask(task)) {
    qCritical() << "更新任务失败:" << db->lastError();
    // 错误处理逻辑
}
```

#### 3. 事务管理
- **批量操作：** 使用事务包装批量数据库操作
```cpp
QSqlDatabase::database().transaction();
for (const auto &task : tasks) {
    db->insertTask(task);
}
QSqlDatabase::database().commit();
```

#### 4. 线程安全
- **禁止跨线程：** 数据库连接不能跨线程使用
- **长时间查询：** 在独立线程执行，完成后用信号通知UI线程

### **代码质量检查清单**

在完成每个功能模块后，必须检查以下项目：

#### Qt特定检查
- [ ] 所有QObject派生对象是否正确设置父对象？
- [ ] 信号槽连接是否使用新式语法？
- [ ] 是否存在信号槽连接泄漏（对象销毁但连接未断开）？
- [ ] UI操作是否全部在UI线程执行？
- [ ] 是否正确使用了Qt的元对象系统（Q_OBJECT宏）？

#### 数据库检查
- [ ] 数据库操作返回值是否全部检查？
- [ ] 是否通过DatabaseManager单例访问数据库？
- [ ] 批量操作是否使用事务？
- [ ] 数据库连接是否在正确的线程？

#### 资源管理检查
- [ ] new创建的对象是否有对应的delete或父对象管理？
- [ ] 文件、数据库连接等资源是否正确关闭？
- [ ] 是否存在循环引用导致的内存泄漏？

#### 中文本地化检查
- [ ] 所有用户可见的文本是否已翻译为中文？
- [ ] 代码注释是否使用中文？
- [ ] 错误消息、提示信息是否使用中文？

#### 代码风格检查
- [ ] 是否使用`nullptr`而非`NULL`？
- [ ] 是否使用范围for循环遍历容器？
- [ ] 变量命名是否清晰且符合驼峰命名规范？
- [ ] 是否避免了魔法数字（使用常量或枚举）？

### **Git版本控制规范**

#### Commit Message格式

```
[类型] 简要描述（不超过50字符）

详细说明（可选，每行不超过72字符）
- 变更点1
- 变更点2

关联任务：[任务编号]
```

#### 类型标签
- `[功能]` - 新功能实现
- `[修复]` - Bug修复
- `[重构]` - 代码重构（不改变功能）
- `[文档]` - 文档更新
- `[优化]` - 性能优化
- `[测试]` - 测试相关
- `[配置]` - 配置文件或构建系统修改
- `[UI]` - UI界面调整

#### 提交时机
**必须提交的节点：**
1. 完成一个完整的功能模块
2. 完成一个阶段的所有任务
3. 修复一个重要bug
4. 完成文档的重大更新
5. 每日工作结束前（如有未提交的有效变更）

**示例：**
```bash
[功能] 实现任务快速添加组件

- 创建SimpleAddWidget自定义组件
- 实现基本的任务标题输入和提交功能
- 集成到主界面中间卡片区域
- 添加输入验证和错误提示

关联任务：[002]-任务5.2
```

#### 分支管理（如使用）
- `main` - 主分支，保持稳定可运行状态
- `develop` - 开发分支，日常开发工作
- `feature/xxx` - 功能分支，开发特定功能
- `bugfix/xxx` - 修复分支，修复特定问题

### **资源文件管理规范**

#### 图标资源
- **格式要求：** 统一使用SVG格式
- **命名规范：** 小写字母，单词间用连字符分隔
  - 示例：`add.svg`, `delete.svg`, `high-priority.svg`
- **分类存储：** 按功能分类存放在`icons/`子目录
- **引用方式：** 通过`IconManager`统一管理和加载

#### Qt资源文件（.qrc）
- **resources.qrc：** 主资源文件，包含所有图标和资源
- **更新规范：** 添加新资源后必须更新.qrc文件
- **前缀使用：** 使用逻辑前缀组织资源
```xml
<RCC>
    <qresource prefix="/icons/actions">
        <file>icons/actions/add.svg</file>
    </qresource>
</RCC>
```

### **CMake配置规范**

#### 模块依赖
必须包含的Qt模块：
```cmake
find_package(Qt6 REQUIRED COMPONENTS 
    Widgets    # UI框架
    Sql        # 数据库支持
)

target_link_libraries(k-memo PRIVATE 
    Qt6::Widgets 
    Qt6::Sql
)
```

#### 编译选项
```cmake
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Qt自动处理
set(CMAKE_AUTOMOC ON)  # 元对象编译
set(CMAKE_AUTOUIC ON)  # UI文件编译
set(CMAKE_AUTORCC ON)  # 资源文件编译
```

### **文档编号规范（详细说明）**

| 编号范围 | 文档类型 | 用途说明 | 示例 |
|---------|---------|---------|------|
| 000-099 | 核心文档 | 项目架构、数据库设计、API文档等基础文档 | `[000]功能模块文档.md`<br>`[003]数据库设计文档.md` |
| 100-199 | 阶段性文档 | 各阶段实施方案、技术方案、实现报告 | `[101]用户登录功能实施方案.md`<br>`[102]UI重构技术方案.md` |
| 200-299 |测试修复文档 | 功能测试、bug修复方案、完善升级方案 | `[201]任务模块功能测试.md`<br>`[202]数据库性能优化方案.md` |
| 300-399 | 技术专题文档 | 技术使用说明、教学文档、最佳实践 | `[301]Qt信号槽机制说明.md`<br>`[302]CMake配置指南.md` |

