# K-memo Qt日志系统开发文档

**项目编号：** [303]  
**文档类型：** 技术专题文档  
**创建时间：** 2025-10-25  
**适用版本：** K-memo v1.0+  
**技术栈：** Qt6 Core日志系统 + 自定义LogManager  

---

## 📑 目录

- [一、概述](#一概述)
- [二、设计方案](#二设计方案)
- [三、LogManager实现](#三logmanager实现)
- [四、使用指南](#四使用指南)
- [五、配置说明](#五配置说明)
- [六、最佳实践](#六最佳实践)
- [七、性能考虑](#七性能考虑)
- [八、故障排查](#八故障排查)

---

## 一、概述

### 1.1 为什么需要日志系统？

**日志系统的价值：**
- 🐛 **调试辅助** - 快速定位问题根源
- 📊 **运行监控** - 了解应用运行状态
- 🔍 **问题追溯** - 复现和分析历史问题
- 📈 **性能分析** - 识别性能瓶颈
- 🛡️ **安全审计** - 记录关键操作

### 1.2 技术选型

**为什么选择Qt内置日志系统？**

| 对比项 | Qt内置日志 | log4qt | spdlog |
|-------|-----------|--------|--------|
| **依赖** | 零依赖 ✅ | 需要外部库 | 需要外部库 |
| **QML集成** | 原生支持 ✅ | 需要适配 | 需要适配 |
| **性能** | 优秀 ✅ | 良好 | 优秀 |
| **学习曲线** | 平缓 ✅ | 陡峭 | 中等 |
| **维护成本** | 最低 ✅ | 中等 | 中等 |
| **适用场景** | 轻量级应用 ✅ | 企业应用 | 高性能应用 |

**结论：** 对于K-memo这种轻量级桌面应用，Qt内置日志系统完全满足需求。

### 1.3 架构设计

```
┌─────────────────────────────────────────┐
│  应用层 (C++ / QML)                     │
│  qDebug() / qInfo() / qWarning()       │
│  qCritical() / qFatal()                │
│  console.log() / console.warn()        │
└──────────────┬──────────────────────────┘
               │
┌──────────────┴──────────────────────────┐
│  LogManager (自定义日志管理器)         │
│  - 消息格式化                          │
│  - 日志分类（Category）                │
│  - 文件输出                            │
│  - 级别过滤                            │
└──────────────┬──────────────────────────┘
               │
┌──────────────┴──────────────────────────┐
│  Qt日志系统                             │
│  qInstallMessageHandler()               │
└──────────────┬──────────────────────────┘
               │
┌──────────────┴──────────────────────────┐
│  输出目标                               │
│  - 控制台 (stderr)                     │
│  - 日志文件 (data/logs/*.log)         │
└─────────────────────────────────────────┘
```

---

## 二、设计方案

### 2.1 核心特性

#### 特性1：日志级别管理

Qt提供5个日志级别（从低到高）：

| 级别 | 宏函数 | 用途 | 生产环境 |
|-----|-------|------|----------|
| **Debug** | `qDebug()` | 详细调试信息 | 禁用 ❌ |
| **Info** | `qInfo()` | 一般信息 | 启用 ✅ |
| **Warning** | `qWarning()` | 警告信息 | 启用 ✅ |
| **Critical** | `qCritical()` | 严重错误 | 启用 ✅ |
| **Fatal** | `qFatal()` | 致命错误（中止程序） | 启用 ✅ |

#### 特性2：日志分类（QLoggingCategory）

使用分类系统组织日志：

```cpp
Q_DECLARE_LOGGING_CATEGORY(lcDatabase)    // 数据库操作
Q_DECLARE_LOGGING_CATEGORY(lcModel)       // 数据模型
Q_DECLARE_LOGGING_CATEGORY(lcUI)          // UI相关
Q_DECLARE_LOGGING_CATEGORY(lcQml)         // QML日志
Q_DECLARE_LOGGING_CATEGORY(lcPerformance) // 性能监控
```

**优势：**
- ✅ 按模块分类，便于过滤
- ✅ 可以独立控制每个分类的启用/禁用
- ✅ 便于定位问题所在模块

#### 特性3：环境区分

```cpp
#ifdef QT_DEBUG
    // 开发模式：详细日志 + 控制台输出
    LogManager::instance()->setLogLevel(LogManager::Debug);
    LogManager::instance()->enableFileLogging(false);
#else
    // 生产模式：仅警告以上 + 文件输出
    LogManager::instance()->setLogLevel(LogManager::Warning);
    LogManager::instance()->enableFileLogging(true);
#endif
```

#### 特性4：日志格式化

**标准输出格式：**
```
[时间戳] [级别] [分类] [文件:行号] 消息内容
```

**示例：**
```
[2025-10-25 14:30:15.123] [DEBUG] [kmemo.database] [databasemanager.cpp:145] Inserting task: abc123
[2025-10-25 14:30:15.156] [INFO ] [kmemo.model] [taskmodel.cpp:78] Task added. Total tasks: 15
[2025-10-25 14:30:15.201] [WARN ] [kmemo.qml] [Main.qml:42] Input validation failed
```

### 2.2 目录结构

```
k-memo/
├── utils/                        # 工具类目录 ⭐ 新增
│   ├── logmanager.h             # 日志管理器头文件
│   └── logmanager.cpp           # 日志管理器实现
├── data/
│   └── logs/                    # 日志文件目录（运行时生成）
│       ├── kmemo_20251025_143015.log
│       ├── kmemo_20251025_150023.log
│       └── ...
└── main.cpp                      # 初始化日志系统
```

**重要说明：**
- `utils/` 目录存放通用工具类
- `data/logs/` 在运行时自动创建
- 日志文件按启动时间命名，避免覆盖

---

## 三、LogManager实现

### 3.1 完整代码

详见附录A和附录B。

### 3.2 核心方法说明

#### initialize()
```cpp
void LogManager::initialize(bool enableFileLogging = false);
```
**功能：** 初始化日志系统，安装消息处理器  
**参数：** `enableFileLogging` - 是否启用文件输出  
**调用时机：** main()函数最开始

#### setLogLevel()
```cpp
void LogManager::setLogLevel(LogLevel level);
```
**功能：** 设置最低日志级别  
**参数：** `Debug/Info/Warning/Critical`  
**说明：** 低于此级别的日志将被忽略

#### messageHandler()
```cpp
static void messageHandler(QtMsgType type, 
                           const QMessageLogContext &context, 
                           const QString &msg);
```
**功能：** Qt日志系统回调函数  
**说明：** 所有qDebug/qInfo等调用都会经过此函数

---

## 四、使用指南

### 4.1 初始化（main.cpp）

```cpp
#include "utils/logmanager.h"

int main(int argc, char *argv[]) {
    QGuiApplication app(argc, argv);
    
    // ✅ 第一步：初始化日志系统
#ifdef QT_DEBUG
    LogManager::instance()->initialize(false);  // 开发：仅控制台
    LogManager::instance()->setLogLevel(LogManager::Debug);
#else
    LogManager::instance()->initialize(true);   // 生产：输出文件
    LogManager::instance()->setLogLevel(LogManager::Warning);
#endif
    
    qInfo() << "K-memo application starting...";
    
    // ... 其他初始化代码
}
```

### 4.2 在C++代码中使用

#### 基本用法

```cpp
#include "utils/logmanager.h"

void MyClass::someFunction() {
    qDebug() << "This is a debug message";
    qInfo() << "This is an info message";
    qWarning() << "This is a warning message";
    qCritical() << "This is a critical error";
}
```

#### 使用日志分类

```cpp
#include "utils/logmanager.h"

// 在DatabaseManager中
bool DatabaseManager::insertTask(const Task &task) {
    qCDebug(lcDatabase) << "Inserting task:" << task.id();
    
    QSqlQuery query;
    // ... 执行SQL
    
    if (!query.exec()) {
        qCCritical(lcDatabase) << "Failed to insert:" 
                               << query.lastError().text();
        return false;
    }
    
    qCInfo(lcDatabase) << "Task inserted successfully";
    return true;
}
```

#### 条件日志

```cpp
// 仅在满足条件时输出
if (task.priority() == TaskPriority::Urgent) {
    qCWarning(lcModel) << "Urgent task detected:" << task.title();
}

// 使用格式化字符串
qCInfo(lcPerformance) << QString("Query executed in %1 ms").arg(elapsed);
```

### 4.3 在QML中使用

QML的console对象自动集成到Qt日志系统：

```qml
// Main.qml
Button {
    onClicked: {
        console.log("Button clicked")       // → qDebug()
        console.info("Info message")        // → qInfo()
        console.warn("Warning message")     // → qWarning()
        console.error("Error occurred")     // → qCritical()
        
        // 输出变量
        console.log("Task count:", taskModel.getTaskCount())
        
        // 输出对象
        console.log("Task:", JSON.stringify(task))
    }
}
```

**QML日志特点：**
- 自动标记为`lcQml`分类
- 包含QML文件名和行号
- 支持多个参数输出

---

## 五、配置说明

### 5.1 编译时配置

#### CMakeLists.txt

```cmake
# 添加utils目录到构建
set(PROJECT_SOURCES
    main.cpp
    
    # 工具类
    utils/logmanager.h
    utils/logmanager.cpp
    
    # 其他源文件...
)

# 开发构建：启用详细日志
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    add_definitions(-DQT_DEBUG)
    add_definitions(-DQT_MESSAGELOGCONTEXT)  # 启用文件名和行号
endif()
```

### 5.2 运行时配置

#### 日志级别控制

```cpp
// 在应用运行时动态调整
LogManager::instance()->setLogLevel(LogManager::Info);
```

#### 分类控制

```cpp
// 禁用特定分类
QLoggingCategory::setFilterRules("kmemo.performance=false");

// 启用特定分类
QLoggingCategory::setFilterRules("kmemo.database.debug=true");

// 多个规则
QLoggingCategory::setFilterRules(
    "kmemo.*.debug=false\n"        // 禁用所有Debug
    "kmemo.database.warning=true"  // 启用数据库Warning
);
```

### 5.3 日志文件管理

#### 日志文件位置

```cpp
// Windows: C:\Users\<用户名>\AppData\Local\K-memo\logs\
// Linux:   ~/.local/share/K-memo/logs/
// macOS:   ~/Library/Application Support/K-memo/logs/

QString logPath = QStandardPaths::writableLocation(
    QStandardPaths::AppDataLocation) + "/logs";
```

#### 日志文件命名

```
kmemo_YYYYMMDD_HHMMSS.log
示例：kmemo_20251025_143015.log
```

#### 日志清理策略（可选）

```cpp
// LogManager中添加清理旧日志的方法
void LogManager::cleanOldLogs(int keepDays = 7) {
    QDir logDir(m_logPath);
    QFileInfoList files = logDir.entryInfoList(
        QStringList() << "kmemo_*.log",
        QDir::Files,
        QDir::Time | QDir::Reversed
    );
    
    QDateTime threshold = QDateTime::currentDateTime()
                            .addDays(-keepDays);
    
    for (const QFileInfo &file : files) {
        if (file.lastModified() < threshold) {
            QFile::remove(file.absoluteFilePath());
        }
    }
}
```

---

## 六、最佳实践

### 6.1 日志级别使用准则

| 级别 | 使用场景 | 示例 |
|-----|---------|------|
| **Debug** | 函数进入/退出、变量值、循环计数 | `qCDebug(lcModel) << "Processing task" << taskId;` |
| **Info** | 关键操作完成、状态变更 | `qCInfo(lcDatabase) << "Database initialized";` |
| **Warning** | 可恢复的错误、不影响主流程 | `qCWarning(lcUI) << "Invalid input, using default";` |
| **Critical** | 严重错误、影响功能 | `qCCritical(lcDatabase) << "Failed to connect";` |
| **Fatal** | 致命错误、程序无法继续 | `qFatal("Configuration file missing");` |

### 6.2 日志内容准则

**✅ 好的日志：**
```cpp
// 包含上下文信息
qCInfo(lcDatabase) << "Task inserted successfully. ID:" << task.id() 
                   << "Title:" << task.title();

// 包含操作结果
qCDebug(lcModel) << "Task list filtered. Before:" << beforeCount 
                 << "After:" << afterCount;

// 包含错误详情
qCCritical(lcDatabase) << "SQL error:" << query.lastError().text() 
                       << "Query:" << query.lastQuery();
```

**❌ 不好的日志：**
```cpp
// 信息不足
qDebug() << "Error";  // 什么错误？

// 过于冗长
qDebug() << "Very very very long message with tons of details...";

// 包含敏感信息
qDebug() << "Password:" << password;  // ⚠️ 安全问题！
```

### 6.3 性能敏感代码

```cpp
// ❌ 错误：即使不输出也会执行字符串拼接
qCDebug(lcPerformance) << "Task:" << task.toJson().toStdString();

// ✅ 正确：使用条件判断
if (lcPerformance().isDebugEnabled()) {
    qCDebug(lcPerformance) << "Task:" << task.toJson();
}

// ✅ 更好：使用宏（如果日志被禁用，整个表达式不会编译）
#ifdef QT_DEBUG
    qCDebug(lcPerformance) << "Expensive operation:" << calculateStats();
#endif
```

---

## 七、性能考虑

### 7.1 性能开销分析

| 操作 | 开销 | 说明 |
|-----|------|------|
| qDebug()调用 | 极低 | 如果级别被过滤，几乎无开销 |
| 字符串格式化 | 低 | 仅在实际输出时执行 |
| 文件写入 | 中 | 使用缓冲区，批量写入 |
| 锁竞争 | 极低 | QMutex保护，但持有时间极短 |

### 7.2 优化建议

#### 1. 避免频繁日志

```cpp
// ❌ 不要在循环中大量输出
for (const Task &task : tasks) {
    qDebug() << "Processing" << task.id();  // 1000次循环 = 1000行日志
}

// ✅ 应该：汇总输出
qDebug() << "Processing" << tasks.size() << "tasks";
```

#### 2. 使用合适的日志级别

```cpp
// ❌ 不要滥用Warning/Critical
qCWarning(lcModel) << "Task count is" << count;  // 这只是Info级别

// ✅ 应该
qCInfo(lcModel) << "Task count is" << count;
```

#### 3. 生产环境优化

```cpp
// 生产环境禁用Debug日志
#ifndef QT_DEBUG
    // Debug日志完全不编译
    #define qCDebug(category) QNoDebug()
#endif
```

---

## 八、故障排查

### 8.1 常见问题

#### 问题1：日志没有输出

**可能原因：**
- 日志级别设置过高
- 日志分类被禁用
- 没有调用`initialize()`

**解决方法：**
```cpp
// 检查初始化
qInfo() << "Test log output";  // 如果这条能显示，说明系统正常

// 检查级别
LogManager::instance()->setLogLevel(LogManager::Debug);

// 检查分类
QLoggingCategory::setFilterRules("*.debug=true");
```

#### 问题2：日志文件为空

**可能原因：**
- 文件路径没有写权限
- 程序异常退出，缓冲区未刷新

**解决方法：**
```cpp
// 在LogManager析构函数中确保刷新
LogManager::~LogManager() {
    if (m_logFile.isOpen()) {
        m_logStream.flush();  // ✅ 强制刷新
        m_logFile.close();
    }
}
```

#### 问题3：QML日志不显示

**解决方法：**
```cpp
// 确保QML日志分类已启用
Q_LOGGING_CATEGORY(lcQml, "kmemo.qml", QtDebugMsg);  // 默认启用Debug
```

### 8.2 调试技巧

#### 技巧1：临时启用详细日志

```bash
# Windows环境变量
set QT_LOGGING_RULES="*.debug=true"
k-memo.exe

# Linux/Mac环境变量
QT_LOGGING_RULES="*.debug=true" ./k-memo
```

#### 技巧2：查看特定模块日志

```bash
# 仅查看数据库日志
QT_LOGGING_RULES="kmemo.database.*=true;*=false" ./k-memo
```

#### 技巧3：重定向日志到文件

```bash
# Windows PowerShell
.\k-memo.exe 2>&1 | Tee-Object -FilePath debug.log

# Linux/Mac
./k-memo 2>&1 | tee debug.log
```

---

## 附录A：logmanager.h完整代码

```cpp
#ifndef LOGMANAGER_H
#define LOGMANAGER_H

#include <QObject>
#include <QFile>
#include <QTextStream>
#include <QDateTime>
#include <QMutex>
#include <QLoggingCategory>

/**
 * @brief LogManager - K-memo日志管理器
 * 
 * 基于Qt内置日志系统的轻量级日志管理器
 * 提供日志分类、级别过滤、文件输出等功能
 * 
 * @author K-memo Team
 * @date 2025-10-25
 */
class LogManager : public QObject {
    Q_OBJECT
    
public:
    /**
     * @brief 获取单例实例
     * @return LogManager* 全局唯一实例
     */
    static LogManager* instance();
    
    /**
     * @brief 初始化日志系统
     * @param enableFileLogging 是否启用文件输出
     * 
     * ⚠️ 必须在main()函数最开始调用
     */
    void initialize(bool enableFileLogging = false);
    
    /**
     * @brief 日志级别枚举
     */
    enum LogLevel {
        Debug,      // 详细调试信息
        Info,       // 一般信息
        Warning,    // 警告信息
        Critical    // 严重错误
    };
    Q_ENUM(LogLevel)
    
    /**
     * @brief 设置最低日志级别
     * @param level 日志级别
     * 
     * 低于此级别的日志将被忽略
     */
    void setLogLevel(LogLevel level);
    
    /**
     * @brief 设置日志文件路径
     * @param path 日志文件完整路径
     */
    void setLogFilePath(const QString &path);
    
    /**
     * @brief 启用/禁用文件日志
     * @param enabled 是否启用
     */
    void enableFileLogging(bool enabled);
    
    /**
     * @brief Qt消息处理回调函数
     * 
     * 通过qInstallMessageHandler()安装
     */
    static void messageHandler(QtMsgType type,
                               const QMessageLogContext &context,
                               const QString &msg);
    
private:
    explicit LogManager(QObject *parent = nullptr);
    ~LogManager();
    
    // 禁止拷贝和赋值
    Q_DISABLE_COPY(LogManager)
    
    /**
     * @brief 格式化日志消息
     * @param type 消息类型
     * @param context 消息上下文（文件、行号等）
     * @param msg 原始消息
     * @return 格式化后的消息字符串
     */
    QString formatMessage(QtMsgType type,
                         const QMessageLogContext &context,
                         const QString &msg);
    
    /**
     * @brief 将QtMsgType转换为字符串
     */
    QString msgTypeToString(QtMsgType type) const;
    
    /**
     * @brief 检查消息是否应该输出
     */
    bool shouldLog(QtMsgType type) const;
    
    static LogManager *s_instance;      // 单例实例
    QFile m_logFile;                     // 日志文件
    QTextStream m_logStream;             // 文件输出流
    QMutex m_mutex;                      // 线程安全锁
    LogLevel m_logLevel;                 // 最低日志级别
    bool m_fileLoggingEnabled;           // 是否启用文件输出
    QString m_logFilePath;               // 日志文件路径
};

// ========================================
// 日志分类定义
// ========================================

/**
 * @brief 数据库操作日志
 * 用于DatabaseManager中的SQL执行、连接管理等
 */
Q_DECLARE_LOGGING_CATEGORY(lcDatabase)

/**
 * @brief 数据模型日志
 * 用于TaskModel、Task等数据模型操作
 */
Q_DECLARE_LOGGING_CATEGORY(lcModel)

/**
 * @brief UI相关日志
 * 用于C++侧的UI组件、事件处理等
 */
Q_DECLARE_LOGGING_CATEGORY(lcUI)

/**
 * @brief 性能监控日志
 * 用于性能分析、耗时统计等
 */
Q_DECLARE_LOGGING_CATEGORY(lcPerformance)

/**
 * @brief QML日志
 * 用于QML侧的console.log等输出
 */
Q_DECLARE_LOGGING_CATEGORY(lcQml)

#endif // LOGMANAGER_H
```

---

## 附录B：logmanager.cpp完整代码

```cpp
#include "logmanager.h"
#include <QStandardPaths>
#include <QDir>
#include <QDebug>

// ========================================
// 定义日志分类
// ========================================
Q_LOGGING_CATEGORY(lcDatabase, "kmemo.database")
Q_LOGGING_CATEGORY(lcModel, "kmemo.model")
Q_LOGGING_CATEGORY(lcUI, "kmemo.ui")
Q_LOGGING_CATEGORY(lcPerformance, "kmemo.performance")
Q_LOGGING_CATEGORY(lcQml, "kmemo.qml")

// ========================================
// 静态成员初始化
// ========================================
LogManager* LogManager::s_instance = nullptr;

// ========================================
// 公共方法实现
// ========================================

LogManager* LogManager::instance() {
    if (!s_instance) {
        s_instance = new LogManager();
    }
    return s_instance;
}

void LogManager::initialize(bool enableFileLogging) {
    m_fileLoggingEnabled = enableFileLogging;
    
    // 如果启用文件日志，创建日志文件
    if (m_fileLoggingEnabled) {
        // 获取日志目录：AppDataLocation/logs/
        QString logDir = QStandardPaths::writableLocation(
            QStandardPaths::AppDataLocation) + "/logs";
        
        // 创建目录（如果不存在）
        QDir dir;
        if (!dir.exists(logDir)) {
            dir.mkpath(logDir);
        }
        
        // 生成日志文件名：kmemo_YYYYMMDD_HHMMSS.log
        QString timestamp = QDateTime::currentDateTime()
                            .toString("yyyyMMdd_HHmmss");
        m_logFilePath = QString("%1/kmemo_%2.log")
                        .arg(logDir)
                        .arg(timestamp);
        
        // 打开日志文件
        m_logFile.setFileName(m_logFilePath);
        if (m_logFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
            m_logStream.setDevice(&m_logFile);
            
            // 写入文件头
            m_logStream << "========================================\n";
            m_logStream << "K-memo Application Log\n";
            m_logStream << "Start Time: " << QDateTime::currentDateTime()
                                            .toString("yyyy-MM-dd HH:mm:ss") << "\n";
            m_logStream << "========================================\n";
            m_logStream.flush();
            
            qInfo() << "Log file created:" << m_logFilePath;
        } else {
            qWarning() << "Failed to create log file:" << m_logFilePath;
        }
    }
    
    // 安装消息处理器
    qInstallMessageHandler(LogManager::messageHandler);
    
    qInfo() << "LogManager initialized. File logging:" 
            << (m_fileLoggingEnabled ? "enabled" : "disabled");
}

void LogManager::setLogLevel(LogLevel level) {
    m_logLevel = level;
    qInfo() << "Log level set to:" << level;
}

void LogManager::setLogFilePath(const QString &path) {
    QMutexLocker locker(&m_mutex);
    
    // 关闭旧文件
    if (m_logFile.isOpen()) {
        m_logStream.flush();
        m_logFile.close();
    }
    
    // 打开新文件
    m_logFilePath = path;
    m_logFile.setFileName(path);
    if (m_logFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        m_logStream.setDevice(&m_logFile);
        qInfo() << "Log file changed to:" << path;
    } else {
        qWarning() << "Failed to open new log file:" << path;
    }
}

void LogManager::enableFileLogging(bool enabled) {
    m_fileLoggingEnabled = enabled;
    
    if (!enabled && m_logFile.isOpen()) {
        QMutexLocker locker(&m_mutex);
        m_logStream.flush();
        m_logFile.close();
        qInfo() << "File logging disabled";
    } else if (enabled && !m_logFile.isOpen()) {
        initialize(true);
    }
}

void LogManager::messageHandler(QtMsgType type,
                                const QMessageLogContext &context,
                                const QString &msg) {
    LogManager *manager = LogManager::instance();
    
    // 检查是否应该输出
    if (!manager->shouldLog(type)) {
        return;
    }
    
    // 格式化消息
    QString formattedMsg = manager->formatMessage(type, context, msg);
    
    // 输出到控制台
    fprintf(stderr, "%s\n", formattedMsg.toLocal8Bit().constData());
    
    // 输出到文件
    if (manager->m_fileLoggingEnabled && manager->m_logFile.isOpen()) {
        QMutexLocker locker(&manager->m_mutex);
        manager->m_logStream << formattedMsg << "\n";
        manager->m_logStream.flush();  // 立即刷新，防止异常退出丢失日志
    }
    
    // Fatal消息：中止程序
    if (type == QtFatalMsg) {
        abort();
    }
}

// ========================================
// 私有方法实现
// ========================================

LogManager::LogManager(QObject *parent)
    : QObject(parent)
    , m_logLevel(Debug)  // 默认Debug级别
    , m_fileLoggingEnabled(false)
{
}

LogManager::~LogManager() {
    // 确保所有日志都被写入
    if (m_logFile.isOpen()) {
        QMutexLocker locker(&m_mutex);
        m_logStream << "\n========================================\n";
        m_logStream << "End Time: " << QDateTime::currentDateTime()
                                      .toString("yyyy-MM-dd HH:mm:ss") << "\n";
        m_logStream << "========================================\n";
        m_logStream.flush();
        m_logFile.close();
    }
}

QString LogManager::formatMessage(QtMsgType type,
                                  const QMessageLogContext &context,
                                  const QString &msg) {
    // 格式：[时间戳] [级别] [分类] [文件:行号] 消息
    QString timestamp = QDateTime::currentDateTime()
                        .toString("yyyy-MM-dd HH:mm:ss.zzz");
    
    QString typeStr = msgTypeToString(type);
    
    // 提取分类名称（如果有）
    QString category;
    if (context.category && QString(context.category) != "default") {
        category = QString("[%1]").arg(context.category);
    }
    
    // 提取文件名和行号（仅在Debug构建中）
    QString location;
#ifdef QT_MESSAGELOGCONTEXT
    if (context.file) {
        // 仅显示文件名，不显示完整路径
        QString fileName = QString(context.file).split('/').last()
                                                 .split('\\').last();
        location = QString("[%1:%2]").arg(fileName).arg(context.line);
    }
#endif
    
    // 组装最终消息
    return QString("[%1] [%2] %3 %4 %5")
           .arg(timestamp)
           .arg(typeStr, -8)  // 左对齐，宽度8
           .arg(category, -20) // 左对齐，宽度20
           .arg(location, -30) // 左对齐，宽度30
           .arg(msg);
}

QString LogManager::msgTypeToString(QtMsgType type) const {
    switch (type) {
        case QtDebugMsg:    return "DEBUG";
        case QtInfoMsg:     return "INFO";
        case QtWarningMsg:  return "WARNING";
        case QtCriticalMsg: return "CRITICAL";
        case QtFatalMsg:    return "FATAL";
        default:            return "UNKNOWN";
    }
}

bool LogManager::shouldLog(QtMsgType type) const {
    // 将QtMsgType映射到LogLevel
    int msgLevel = 0;
    switch (type) {
        case QtDebugMsg:    msgLevel = Debug; break;
        case QtInfoMsg:     msgLevel = Info; break;
        case QtWarningMsg:  msgLevel = Warning; break;
        case QtCriticalMsg:
        case QtFatalMsg:    msgLevel = Critical; break;
    }
    
    // 只输出大于等于设定级别的消息
    return msgLevel >= m_logLevel;
}
```

---

## 附录C：main.cpp集成示例

```cpp
#include <QGuiApplication>
#include <QQmlApplicationEngine>
#include <QQmlContext>
#include "utils/logmanager.h"
#include "models/taskmodel.h"
#include "database/databasemanager.h"
#include "managers/traymanager.h"
#include "managers/notificationmanager.h"

int main(int argc, char *argv[]) {
    QGuiApplication app(argc, argv);
    
    // ========================================
    // ✅ 第一步：初始化日志系统
    // ========================================
#ifdef QT_DEBUG
    // 开发模式：仅控制台输出，Debug级别
    LogManager::instance()->initialize(false);
    LogManager::instance()->setLogLevel(LogManager::Debug);
    
    qInfo() << "Running in DEBUG mode";
#else
    // 生产模式：输出到文件，Warning级别
    LogManager::instance()->initialize(true);
    LogManager::instance()->setLogLevel(LogManager::Warning);
    
    qInfo() << "Running in RELEASE mode";
#endif
    
    qInfo() << "K-memo application starting...";
    
    // ========================================
    // 第二步：初始化数据库
    // ========================================
    qCInfo(lcDatabase) << "Initializing database...";
    DatabaseManager *db = DatabaseManager::instance();
    if (!db) {
        qCCritical(lcDatabase) << "Failed to initialize database!";
        return -1;
    }
    qCInfo(lcDatabase) << "Database initialized successfully";
    
    // ========================================
    // 第三步：创建数据模型
    // ========================================
    qCInfo(lcModel) << "Creating TaskModel...";
    TaskModel taskModel;
    qCInfo(lcModel) << "TaskModel created. Task count:" 
                    << taskModel.getTaskCount();
    
    // ========================================
    // 第四步：初始化QML引擎
    // ========================================
    qCInfo(lcUI) << "Initializing QML engine...";
    QQmlApplicationEngine engine;
    
    // 注册TaskModel到QML上下文
    engine.rootContext()->setContextProperty("taskModel", &taskModel);
    
    // 加载主QML文件
    const QUrl url(u"qrc:/qml/Main.qml"_qs);
    engine.load(url);
    
    if (engine.rootObjects().isEmpty()) {
        qCCritical(lcQml) << "Failed to load QML!";
        return -1;
    }
    
    qCInfo(lcUI) << "QML loaded successfully";
    
    // ========================================
    // 第五步：启动应用程序
    // ========================================
    qInfo() << "Application started. Entering event loop...";
    int result = app.exec();
    
    qInfo() << "Application exiting with code:" << result;
    return result;
}
```

---

## 附录D：CMakeLists.txt配置示例

```cmake
cmake_minimum_required(VERSION 3.16)
project(k-memo VERSION 1.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Qt配置
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)

# 查找Qt模块
find_package(Qt6 REQUIRED COMPONENTS
    Core
    Quick
    Qml
    QuickControls2
    Sql
)

# 源文件列表
set(PROJECT_SOURCES
    main.cpp
    
    # ⭐ 工具类（新增）
    utils/logmanager.h
    utils/logmanager.cpp
    
    # 数据模型
    models/task.h
    models/task.cpp
    models/taskmodel.h
    models/taskmodel.cpp
    
    # 数据库
    database/databasemanager.h
    database/databasemanager.cpp
    
    # 管理器
    managers/traymanager.h
    managers/traymanager.cpp
    managers/notificationmanager.h
    managers/notificationmanager.cpp
    
    # 资源文件
    resources.qrc
)

# QML文件（可选，用于IDE识别）
set(QML_FILES
    qml/Main.qml
    qml/components/cards/StatsCard.qml
    qml/components/cards/AddTaskCard.qml
    qml/components/cards/TaskListCard.qml
    qml/components/items/TaskItem.qml
)

# 创建可执行文件
qt_add_executable(k-memo
    ${PROJECT_SOURCES}
)

# QML模块（Qt6.2+）
qt_add_qml_module(k-memo
    URI KMemo
    VERSION 1.0
    QML_FILES ${QML_FILES}
)

# 链接Qt库
target_link_libraries(k-memo PRIVATE
    Qt6::Core
    Qt6::Quick
    Qt6::Qml
    Qt6::QuickControls2
    Qt6::Sql
)

# ⭐ Debug构建：启用消息上下文
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    add_definitions(-DQT_MESSAGELOGCONTEXT)  # 启用文件名和行号
    message(STATUS "Debug build: QT_MESSAGELOGCONTEXT enabled")
endif()

# 安装配置
install(TARGETS k-memo
    BUNDLE DESTINATION .
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)
```

---

**文档版本：** v1.0  
**最后更新：** 2025-10-25  
**维护人员：** K-memo开发团队  
**相关文档：**
- `[101]Qt Quick重构技术方案.md` - UI重构总体方案
- `[003]数据库设计文档.md` - 数据库架构
- `CLAUDE.md` - 项目开发指南

**完成状态：** ✅ 文档编写完成

---

## 文档变更记录

| 版本 | 日期 | 变更说明 |
|-----|------|---------|
| v1.0 | 2025-10-25 | 初始版本，完整的日志系统设计和实现 |

